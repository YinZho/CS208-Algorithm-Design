# 问题描述

仅仅只是Huffman编解码问题，没有别的。这次分为两个小题，压缩和解压。这个小题为`解压`。

需要同学们通过给定的文件头byte数字串以及给定的压缩后的byte数字串，还原原来的文件。

# 各种格式

## 头文件格式

为了显的这个题不那么简单，我们将Huffman编码表编写成一个header. 如下图所示。

![head_format](https://cs208-1255649684.cos.ap-guangzhou.myqcloud.com/Untitled%20Diagram.png)

第一个8个bit表示为第一个编码的长度L_1L1, 接下来L_1L1个bit为第一个编码。
第二个8个bit表示为第一个编码的长度L_2L2, 接下来L_2L2个bit为第二个编码。
以此类推，总共有256个编码。
接下来32个bit表示压缩文件有效bit数。

## 输入格式

压缩文件包含两个部分，压缩文件头以及压缩文件内容。
仅一行，输入形式为byte数字串，代表文件流。byte数字串末尾会加-1，代表文件结束。

## 输出格式

一个整数，表示解压过后生产byte数字串的长度

# 例子

假如我们现在有一个文件包含”AABBBC“
则这个文件的byte数字串为（输入） 65 65 66 66 66 67 -1 （-1代表文件的末尾标志）
根据byte数字串构建Huffman编码树，则生成的编码表为 65：10， 66：0， 67： 11
压缩过后的bit串为101000011 有效压缩bit数为9。
根据构建的Huffman编码树以及压缩后bit串的长度可得，定义文件头为
![example](https://cs208-1255649684.cos.ap-guangzhou.myqcloud.com/Example.png)

## 输入

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 128 64 88 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 77 12 -1


Copy
```

## 输出

6

# 数据大小

解压后的文件小于1MB

# 时间内存限制

时间限制: 1 s
内存限制：262144 KiB

# 提示

先解码文件头，转换成Huffman编码表。通过输入的byte数字串可以还原压缩的01比特串。再通过查找Huffman编码表替换01比特串为解压前byte数字串。